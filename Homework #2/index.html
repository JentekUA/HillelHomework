<!-- 1. false && true || true => true
Объяснение:
&& возвращает левый операнд если он вычисляется в false. false && true => false;
Так как в выражении false || true первый операнд false - проверка идёт дальше и возвращает правый true;
false && true || true => false || true => true;

2. false && (true || true) => false
Объяснение:
Выражение в скобках имеет высший приоритет и вычисляется в первую очередь;
Если левый операнд || вычисляется в true то выражение вычисляется в true. (true || true) => true;
&& возвращает левый операнд если он вычисляется в false. false && true => false;
false && (true || true) => false && true => false;

3. +'40' + +'2' => 42
Объяснение:
Унарный оператор + преобразовывает string в number. +'40' + +'2' => 40 + 2;
Бинарный + производит сложения числа с числом. 40 + 2 = 42;
'40' + +'2' => 40 + 2 => 42;

4. '2' + 3 ** 2 => '29'
Объяснение:
** имеет высший приоритет чем +. 3 ** 2 => 9;
Если один из операндов в бинарном + sting то второй преобразовывается в sting и происходит конкатинация. '2' + 9 => '2' + '9' => '29';
'2' + 3 ** 2 => '2' + 9 => '2' + '9' => '29';

5. 3 ** 2 / 3 => 3
Объяснение:
** имеет высший приоритет чем /. 3 ** 2 => 9;
3 ** 2 / 3 => 9 / 3 => 3;

6. 3 ** (9 / 3) => 27
Объяснение:
Оператор групировки () имеет высший приоритет. (9 / 3) => 3;
3 ** (9 / 3) => 3 ** 3 => 27;

7. '10' + (5 === 6) => '10false'
Объяснение:
Оператор групировки () имеет высший приоритет. (5 === 6) => false;
Если один из операндов в бинарном + sting то второй преобразовывается в sting и происходит конкатинация. '10' + false => '10false';

8. '10' - 5 === 6 => false
Объяснение:
Оператор - имеет высший приоритет чем сторогое равно и по возможности преобразовывает операнды к числу. '10' - 5 => 10 - 5 => 5;
'10' - 5 === 6 => 5 === 6 => false;

9. undefined + 1 => NaN
Объяснение:
При вычислении + оператора если один из операндов не может быть приведён к number то возвращаеся NaN;

10. (+null == false) < 1 => false
Объяснение:
Оператор групировки () имеет высший приоритет;
Унарный + приобразовывает к числу. +null => 0;
== не строгое равно проводит неявное преобразование. false перобразовывается к 0. (0 == false) => (0 == 0) => true;
Оператор < при сравнении разных типов приводит к number; true < 1 => 1 < 1;
(+null == false) < 1 => (0 == false) < 1 => (0 == 0) < 1 => true < 1 => 1 < 1 => false;

11. (+null == false) < 1 ** 5 => false
Объяснение:
Оператор групировки () имеет высший приоритет;
Унарный + приобразовывает к числу. +null => 0;
== не строгое равно проводит неявное преобразование. false перобразовывается к 0. (0 == false) => (0 == 0) => true;
** имеет больший приоритет чем <. true < 1 ** 5 => true < 1;
Оператор < при сравнении разных типов приводит к number; true < 1 => 1 < 1;
(+null == false) < 1 ** 5 => (0 == false) < 1 ** 5 => (0 == 0) < 1 ** 5 => true < 1 ** 5 => true < 1 => 1 < 1 => false;

12.
var number = 5;
2 * ++number; => 12 Объяснение: 2 * на 6 потому что преинкремент применяется перед умножением
2 * number--; => 12 Объяснение: 2 * на 6 потому что постдекремент применяется после умножения. Но number теперь 5
console.log(number); => 5 -->
